<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    body{
        margin: 5em;
    }
</style>
<body>
    <pre>"
      Note: If u copy and paste any of the below codes, don't forget to remove single space in libraries such as #inlcude stdio.h,
      #include stdlib.h, #include stdbool.h,  #include limits.h

      Procedure:

      step 1: open terminal and type the command gedit then press Enter
      step 2: gedit window will displayed then type your source code and save the file in desktop with file as experimentName.c 
      step 3: Again open the terminal, type cd Desktop and enter the run command as follows: gcc experimentName.c and press enter
      srep 4: For displaying the result we use ./a.out and press enter, give input and verify your result.

<h2>1.Depth First Search Algorithm </h2>
        

#include < stdio.h>  
#include < stdlib.h>  
int sourceV,Vertex,Edge,time,visited[10],Graph[10][10];  
void DepthFirstSearch(int i)  {  
int j;  
visited[i]=1;  
printf(" %d->",i++);  
for(j=0;j< Vertex;j++) {  
if(Graph[i][j]==1&&visited[j]==0)  
DepthFirstSearch(j);  }  }  
int main() {  
int i,j,vertex1,vertex2;  
printf("\t\t\tGraphs\n");  
printf("Enter no. of edges:");  
scanf("%d",&Edge);  
printf("Enter no. of vertices:");  
scanf("%d",&Vertex);  
for(i=0;i< Vertex;i++) {  
for(j=0;j< Vertex;j++)  
Graph[i][j]=0; }  
for(i=0;i< Edge;i++) {  
printf("Enter the edges in V1 V2 : ");     
scanf("%d%d",&vertex1,&vertex2);  
Graph[vertex1-1][vertex2-1]=1; }  
for(i=0;i< Vertex;i++) {  
for(j=0;j< Vertex;j++)  
printf(" %d ",Graph[i][j]);  
printf("\n"); }  
printf("Enter source Vertex: ");  
scanf("%d",&sourceV);  
DepthFirstSearch(sourceV-1);  
return 0; } 
 
<b>Output:</b>

Enter no. of edges:4
Enter no. of vertices:4
Enter the edges in V1 V2 : 1 1
Enter the edges in V1 V2 : 1 3
Enter the edges in V1 V2 : 2 2
Enter the edges in V1 V2 : 4 3
 1  0  1  0 
 0  1  0  0 
 0  0  0  0 
 0  0  1  0 
Enter source Vertex: 1
 0-> 1->
 
 <hr/>
 
 <h2>2. Breadth First Search Algorithm</h2>

#include < stdio.h>  
#include < stdlib.h>  
int a_0[30][20],q_1[30],visited_nodes[30],n_8,i_0,j_1,f_5=0,r_2=-1;  
void bfs_logic(int v_8) {  
for (i_0=1;i_0<=n_8;i_0++)  
if(a_0[v_8][i_0] && !visited_nodes[i_0])  
q_1[++r_2]=i_0;  
if(f_5<=r_2) {  
visited_nodes[q_1[f_5]]=1;  
bfs_logic(q_1[f_5++]); }  }  
void main() {  
int v_8;  
printf("\n Enter Vertices_to_represent:");  
scanf("%d",&n_8);  
for (i_0=1;i_0<=n_8;i_0++) {  
q_1[i_0]=0;  
visited_nodes[i_0]=0; }  
printf("\n Enter graph_data especially_in_matrix_format:\n");  
for (i_0=1;i_0<=n_8;i_0++)  
for (j_1=1;j_1<=n_8;j_1++)  
scanf("%d",&a_0[i_0][j_1]);  
printf("\n Enter Starting_vertex_for_traversal:");    
scanf("%d",&v_8);  
bfs_logic(v_8);  
printf("\n Reachable_nodes_are:\n");  
for (i_0=1;i_0<=n_8;i_0++)  
if(visited_nodes[i_0])  
printf("%d\t",i_0);  
else  
printf("\n Bfs not_possible_if_not_proper."); }  
 
<b>Output:</b>

 Enter Vertices_to_represent:3

 Enter graph_data especially_in_matrix_format:
2 4 5
6 8 10
12 13 22

 Enter Starting_vertex_for_traversal:2

 Reachable_nodes_are:
1	2	3	
 
 <hr/>

<h2>3. Kruskalâ€™s Algorithm </h2>

#include< stdio.h> 
#include< stdlib.h> 
int i, j, k, a, b, u, v, n, ne = 1; 
int min, mincost = 0, cost[9][9], parent[9]; 
int find(int); 
int uni(int, int); 
int main()  { 
printf("\n\tImplementation of Kruskal's algorithm\n"); 
printf("\nEnter the no. of vertices:"); 
scanf("%d", &n); 
printf("\nEnter the cost adjacency matrix:\n"); 
for(i = 1; i <= n; i++)  { 
for(j = 1; j <= n; j++) { 
scanf("%d", &cost[i][j]); 
if(cost[i][j] == 0) 
cost[i][j] = 999;  }  } 
printf("The edges of Minimum Cost Spanning Tree are\n"); 
while(ne < n) { 
for(i = 1, min = 999; i <= n; i++)  { 
for(j = 1; j <= n; j++) { 
if(cost[i][j] < min)  { 
min = cost[i][j]; 
a = u = i; 
b = v = j; } } } 
u = find(u); 
v = find(v); 
if(uni(u, v))  { 
printf("%d edge (%d,%d) =%d\n", ne++, a, b, min);  Output: 
mincost += min;  }     
cost[a][b] = cost[b][a] = 999;  } 
printf("\n\tMinimum cost = %d\n", mincost); 
return 0;  } 
int find(int i) { 
while(parent[i]) 
i = parent[i]; 
return i; } 
int uni(int i, int j) { 
if(i != j) { 
parent[j] = i; 
return 1; } 
return 0; } 

<b>Output:</b>

	Implementation of Kruskal's algorithm

Enter the no. of vertices:6

Enter the cost adjacency matrix:
0 3 1 6 0 0
3 0 5 0 3 0
1 5 0 5 6 4 
6 0 5 0 0 2
0 3 6 0 0 6
0 0 4 2 6 0
The edges of Minimum Cost Spanning Tree are
1 edge (1,3) =1
2 edge (4,6) =2
3 edge (1,2) =3
4 edge (2,5) =3
5 edge (3,6) =4

	Minimum cost = 13

<hr/>
 
 
 <h2>4. Dijkstra Algorithm</h2>

#include< stdio.h>  
#define INFINITY 9999  
#define MAX 10   
void dijkstra(int G[MAX][MAX],int n,int startnode);   
int main() {  
int G[MAX][MAX],i,j,n,u;  
printf("Enter no. of vertices:");  
scanf("%d",&n);  
printf("\nEnter the adjacency matrix:\n");  
for(i=0;i< n;i++)  
for(j=0;j< n;j++)  
scanf("%d",&G[i][j]);  
printf("\nEnter the starting node:");  
scanf("%d",&u);  
dijkstra(G,n,u);  
return 0; }  
void dijkstra(int G[MAX][MAX],int n,int startnode) {  
int cost[MAX][MAX],distance[MAX],pred[MAX];  
int visited[MAX],count,mindistance,nextnode,i,j;  
for(i=0;i< n;i++)  
for(j=0;j< n;j++)  
if(G[i][j]==0)  
cost[i][j]=INFINITY;  
else  
cost[i][j]=G[i][j];  
for(i=0;i< n;i++) {  
distance[i]=cost[startnode][i];  
pred[i]=startnode;  
visited[i]=0; }  
distance[startnode]=0;  
visited[startnode]=1;  
count=1;  
while(count< n-1) {  
mindistance=INFINITY;  
for(i=0;i< n;i++)  
if(distance[i]< mindistance&&!visited[i]) {  
mindistance=distance[i];  
nextnode=i; }  
visited[nextnode]=1;  
for(i=0;i< n;i++)  
if(!visited[i])  
if(mindistance+cost[nextnode][i]< distance[i]) {  
distance[i]=mindistance+cost[nextnode][i];  
pred[i]=nextnode; }  
count++; }  
for(i=0;i< n;i++)  
if(i!=startnode) {  
printf("\nDistance of node%d=%d",i,distance[i]);  
printf("\nPath=%d",i);  
j=i;  
do {  
j=pred[j];  
printf("<-%d",j);  
}while(j!=startnode); } }  
 
<b>Output:</b>
 
Enter no. of vertices:5

Enter the adjacency matrix:
0 10 0 30 100
10 0 50 0 0
0 5 0 0 20 10
10 0 20 0 60
100 0 10 60 0

Enter the starting node:0

Distance of node1=10
Path=1<-0
Distance of node2=50
Path=2<-3<-0
Distance of node3=30
Path=3<-0
Distance of node4=60
Path=4<-2<-3<-0
 
 <hr/>
 
 
 <h2>5. Floyd-Warshall Algorithm</h2>
 
#include < stdio.h> 
#include < stdlib.h> 
void floydWarshall(int **graph, int n) { 
int i, j, k; 
for (k = 0; k < n; k++) { 
for (i = 0; i < n; i++) { 
for (j = 0; j < n; j++) { 
if (graph[i][j] > graph[i][k] + graph[k][j]) 
graph[i][j] = graph[i][k] + graph[k][j]; } } } } 
int main(void) { 
int n, i, j; 
printf("Enter the number of vertices: "); 
scanf("%d", &n); 
int **graph = (int **)malloc((long unsigned) n * sizeof(int *)); 
for (i = 0; i < n; i++) { 
graph[i] = (int *)malloc((long unsigned) n * sizeof(int)); } 
for (i = 0; i < n; i++) { 
for (j = 0; j < n; j++) { 
if (i == j) 
graph[i][j] = 0; 
else 
graph[i][j] = 100; } } 
printf("Enter the edges: \n");    
for (i = 0; i < n; i++) { 
for (j = 0; j < n; j++) { 
printf("[%d][%d]: ", i, j); 
scanf("%d", &graph[i][j]); } } 
printf("The original graph is:\n"); 
for (i = 0; i < n; i++) { 
for (j = 0; j < n; j++) { 
printf("%d ", graph[i][j]); } 
printf("\n"); } 
floydWarshall(graph, n); 
printf("The shortest path matrix is:\n"); 
for (i = 0; i < n; i++) { 
for (j = 0; j < n; j++) { 
printf("%d ", graph[i][j]); } 
printf("\n"); } 
return 0; }
 
<b>Output:</b>

Enter the number of vertices: 3
Enter the edges: 
[0][0]: 0
[0][1]: 12
[0][2]: 45
[1][0]: 25
[1][1]: 0
[1][2]: 15
[2][0]: 22
[2][1]: 41
[2][2]: 0
The original graph is:
0 12 45 
25 0 15 
22 41 0 
The shortest path matrix is:
0 12 27 
25 0 15 
22 34 0 

 <hr/>
 
 
  <h2>6. Line Sweeping method</h2>

#include < stdio.h> 
#include < stdlib.h> 
typedef struct { 
int x; 
int y; 
} Point; 
typedef struct { 
Point point; 
int isStart; 
int segIndex; 
} Event; 
typedef struct { 
Point start; 
Point end; 
} LineSegment; 
void swap(Point *p1, Point *p2) { 
Point temp = *p1; 
*p1 = *p2; 
*p2 = temp; } 
int onSegment(Point p, Point q, Point r) { 
return (q.x <= (p.x > r.x ? p.x : r.x) && q.x >= (p.x < r.x ? p.x : r.x) && 
q.y <= (p.y > r.y ? p.y : r.y) && q.y >= (p.y < r.y ? p.y : r.y)); } 
int orientation(Point p, Point q, Point r) { 
int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); 
return (val == 0) ? 0 : (val > 0) ? 1 : 2; } 
int doIntersect(Point p1, Point q1, Point p2, Point q2, Point *intersection) { 
int o1 = orientation(p1, q1, p2); 
int o2 = orientation(p1, q1, q2); 
int o3 = orientation(p2, q2, p1); 
int o4 = orientation(p2, q2, q1); 
int dx1 = q1.x - p1.x; 
int dy1 = q1.y - p1.y; 
int dx2 = q2.x - p2.x; 
int dy2 = q2.y - p2.y; 
int denominator = (dx1 * dy2 - dy1 * dx2); 
if (o1 != o2 && o3 != o4 && denominator != 0) { 
double t1 = ((p1.x - p2.x) * dy2 + (p2.y - p1.y) * dx2) / (double)denominator; 
intersection->x = p1.x + (int)(t1 * dx1); 
intersection->y = p1.y + (int)(t1 * dy1); 
return 1; } 
if (o1 == 0 && onSegment(p1, p2, q1)) { 
*intersection = p2; 
return 1; } 
if (o2 == 0 && onSegment(p1, q2, q1)) { 
*intersection = q2; 
return 1; } 
if (o3 == 0 && onSegment(p2, p1, q2)) { 
*intersection = p1; 
return 1; } 
if (o4 == 0 && onSegment(p2, q1, q2)) { 
*intersection = q1; 
return 1; } 
return 0; } 
int compareEvents(const void *a, const void *b) { 
return ((Event *)a)->point.x - ((Event *)b)->point.x; } 
int main() { 
int numSegments, i, j; 
printf("Enter the number of line segments: "); 
scanf("%d", &numSegments); 
LineSegment *segments = malloc(numSegments * sizeof(LineSegment)); 
printf("Enter coordinates of each line segment:\n"); 
for (i = 0; i < numSegments; i++) { 
printf("Enter coordinates of start point of segment %d (x y): ", i+1); 
scanf("%d %d", &segments[i].start.x, &segments[i].start.y); 
printf("Enter coordinates of end point of segment %d (x y): ", i+1); 
scanf("%d %d", &segments[i].end.x, &segments[i].end.y); 
if (segments[i].start.x > segments[i].end.x) 
swap(&segments[i].start, &segments[i].end); } 
int numEvents = 2 * numSegments; 
Event *events = malloc(numEvents * sizeof(Event)); 
for (i = 0; i < numSegments; i++) { 
events[2*i].point = segments[i].start; 
events[2*i].isStart = 1; 
events[2*i].segIndex = i; 
events[2*i+1].point = segments[i].end; 
events[2*i+1].isStart = 0; 
events[2*i+1].segIndex = i;    } 
qsort(events, numEvents, sizeof(Event), compareEvents); 
printf("Intersection Points:\n"); 
int intersectionCount = 0; 
for (i = 0; i < numEvents; i++) { 
if (events[i].isStart) { 
for (j = i + 1; j < numEvents; j++) { 
if (!events[j].isStart) { 
Point intersection; 
if (doIntersect(segments[events[i].segIndex].start, segments[events[i].segIndex].end, 
segments[events[j].segIndex].start, segments[events[j].segIndex].end, &intersection)) { 
printf("(%d,%d)\n", intersection.x, intersection.y); 
intersectionCount++;     } }  } } } 
printf("Number of intersections: %d\n", intersectionCount); 
free(segments); 
free(events); 
return 0; } 
 
<b>Output:</b>
 
 
Enter the number of line segments: 2
Enter coordinates of each line segment:
Enter coordinates of start point of segment 1 (x y): 1 2
Enter coordinates of end point of segment 1 (x y): 5 4
Enter coordinates of start point of segment 2 (x y): 3 1
Enter coordinates of end point of segment 2 (x y): 4 5
Intersection Points:
(-1,1)
(1,2)
(3,1)
(3,-1)
Number of intersections: 4

 <hr/>

   <h2>7. Kernighan -Lin Algorithm</h2>

#include < stdio.h> 
#include < stdlib.h> 
#define MAX_VERTICES 20 
int adjacency[MAX_VERTICES][MAX_VERTICES] = { 
{0, 1, 1, 0, 0}, 
{1, 0, 1, 1, 1}, 
{1, 1, 0, 0, 1}, 
{0, 1, 0, 0, 1}, 
{0, 1, 1, 1, 0} }; 
int i,j; 
void calculate_initial_gains(int n, int gains[], int A[]) { 
for (i = 0; i < n; ++i) { 
gains[i] = 0; 
for (j = 0; j < n; ++j) { 
if (A[j] == 1) { 
gains[i] -= adjacency[i][j]; 
} else { 
gains[i] += adjacency[i][j]; } }  } } 
void kernighan_lin(int n, int A[], int B[]) { 
int gains[n]; 
int best_gain, best_i, best_j; 
int pass = 0; 
int i,j; 
for (i = 0; i < n; ++i) { 
if (i < n/2) { 
A[i] = 1; // Part A 
B[i] = 0; // Part B 
} else { 
A[i] = 0; // Part A 
B[i] = 1; // Part B 
} } 
while (pass < n/2) { 
calculate_initial_gains(n, gains, A); 
for (i = 0; i < n; ++i) { 
if (A[i] == 1) { 
best_gain = -9999; 
for (j = 0; j < n; ++j) { 
if (B[j] == 0) { 
int gain = gains[i] + gains[j] - 2 * adjacency[i][j]; 
if (gain > best_gain) { 
best_gain = gain; 
best_i = i; 
best_j = j; } } } }} 
A[best_i] = 0; 
B[best_i] = 1; 
A[best_j] = 1; 
B[best_j] = 0; 
pass++; 
} } 
int main() { 
int n; 
printf("Enter the number of vertices (max %d): ", MAX_VERTICES); 
scanf("%d", &n); 
if (n > MAX_VERTICES || n <= 0) { 
printf("Invalid number of vertices.\n"); 
return 1;} 
int A[MAX_VERTICES], B[MAX_VERTICES]; 
kernighan_lin(n, A, B); 
printf("Partition A: "); 
for (i = 0; i < n; ++i) { 
if (A[i] == 1) { 
printf("%d ", i + 1); 
} } 
printf("\n"); 
printf("Partition B: "); 
for (i = 0; i < n; ++i) { 
if (B[i] == 1) { 
printf("%d ", i + 1);} } 
printf("\n"); 
return 0;} 

<b>Output:</b> 
 
Enter the number of vertices (max 20): 3
Partition A: 1 
Partition B: 2 3 

<hr/>
 
 
  <h2>8. Fiduccias- Mattheyses algorithm </h2>

#include < stdio.h> 
#include < stdlib.h> 
#include < stdbool.h> 
#define MAX_NODES 100 
struct Graph { 
int numNodes; 
bool adjMatrix[MAX_NODES][MAX_NODES]; 
}; 
void initializeGraph(struct Graph *graph, int numNodes); 
void addEdge(struct Graph *graph, int u, int v); 
void fiducciaMattheyses(struct Graph *graph, int *partition, int *gain); 
int main() { 
int numNodes = 6; 
struct Graph graph; 
int partition[MAX_NODES]; 
int gain[MAX_NODES]; 
int i; 
initializeGraph(&graph, numNodes); 
addEdge(&graph, 0, 1); 
addEdge(&graph, 0, 2); 
addEdge(&graph, 1, 3); 
addEdge(&graph, 2, 4); 
addEdge(&graph, 3, 5); 
addEdge(&graph, 4, 5); 
fiducciaMattheyses(&graph, partition, gain); 
printf("Partition results:\n"); 
for ( i = 0; i < numNodes; i++) { 
printf("Node %d -> Partition %d\n", i, partition[i]); } 
return 0; } 
void initializeGraph(struct Graph *graph, int numNodes) { 
graph->numNodes = numNodes; 
int i,j; 
for ( i = 0; i < numNodes; i++) { 
for ( j = 0; j < numNodes; j++) { 
graph->adjMatrix[i][j] = false; 
} } } 
void addEdge(struct Graph *graph, int u, int v) { 
graph->adjMatrix[u][v] = true; 
graph->adjMatrix[v][u] = true; 
} 
void fiducciaMattheyses(struct Graph *graph, int *partition, int *gain) { 
int numNodes = graph->numNodes; 
int currentPartition[MAX_NODES]; 
int i,j; 
for (i = 0; i < numNodes; i++) { 
partition[i] = i % 2; 
} 
bool moved = true; 
while (moved) { 
moved = false; 
for (i = 0; i < numNodes; i++) { 
gain[i] = 0; 
 
for (j = 0; j < numNodes; j++) { 
if (graph->adjMatrix[i][j] && partition[i] != partition[j]) { 
gain[i]++; 
} else if (graph->adjMatrix[i][j] && partition[i] == partition[j]) { 
gain[i]--; }  } } 
for ( i = 0; i < numNodes; i++) { 
if (gain[i] > 0) { 
currentPartition[i] = 1 - partition[i]; 
moved = true; } else { 
currentPartition[i] = partition[i]; } } 
for ( i = 0; i < numNodes; i++) { 
partition[i] = currentPartition[i]; 
} } } 
 
<b>Output:</b>
 
Partition results:
Node 0 -> Partition 0
Node 1 -> Partition 1
Node 2 -> Partition 0
Node 3 -> Partition 1
Node 4 -> Partition 0
Node 5 -> Partition 1

<hr/>
 

   <h2>9. Lees Algorithm</h2>

 
#include < stdio.h> 
#include < stdlib.h> 
#include < stdbool.h> 
#include < limits.h> 
#define ROW 8 
#define COL 8 
int dRow[] = {-1, 1, 0, 0}; 
int dCol[] = {0, 0, -1, 1}; 
typedef struct { 
int row, col, dist; 
} Node; 
typedef struct { 
Node* nodes; 
int front, rear, size; 
int capacity; 
} Queue; 
Queue* createQueue(int capacity) { 
Queue* queue = (Queue*)malloc(sizeof(Queue)); 
queue->capacity = capacity; 
queue->front = queue->size = 0; 
queue->rear = capacity - 1; 
queue->nodes = (Node*)malloc(queue->capacity * sizeof(Node)); 
return queue;} 
bool isEmpty(Queue* queue) { 
return (queue->size == 0);} 
void enqueue(Queue* queue, Node node) { 
queue->rear = (queue->rear + 1) % queue->capacity; 
queue->nodes[queue->rear] = node; 
queue->size = queue->size + 1;} 
Node dequeue(Queue* queue) { 
Node node = queue->nodes[queue->front]; 
queue->front = (queue->front + 1) % queue->capacity; 
queue->size = queue->size - 1; 
return node;} 
bool isValid(int grid[ROW][COL], bool visited[ROW][COL], int row, int col) { 
return (row >= 0) && (row < ROW) && (col >= 0) && (col < COL) && 
(grid[row][col] == 0) && (!visited[row][col]);} 
int leeAlgorithm(int grid[ROW][COL], int startX, int startY, int endX, int endY) { 
bool visited[ROW][COL]; 
int i,j; 
for (i = 0; i < ROW; i++) { 
for ( j = 0; j < COL; j++) { 
visited[i][j] = false;} } 
Queue* queue = createQueue(ROW * COL); 
Node start = {startX, startY, 0}; 
enqueue(queue, start); 
visited[startX][startY] = true; 
while (!isEmpty(queue)) { 
Node current = dequeue(queue); 
if (current.row == endX && current.col == endY) { 
free(queue->nodes); 
free(queue); 
return current.dist; } 
for ( i = 0; i < 4; i++) { 
int newRow = current.row + dRow[i]; 
int newCol = current.col + dCol[i]; 
if (isValid(grid, visited, newRow, newCol)) { 
visited[newRow][newCol] = true; 
Node adjNode = {newRow, newCol, current.dist + 1}; 
enqueue(queue, adjNode); } } } 
free(queue->nodes);       
free(queue); 
return INT_MAX; }      
int main() { 
int grid[ROW][COL] = { 
{0, 1, 0, 0, 0, 0, 0, 0}, 
{0, 1, 0, 1, 1, 1, 1, 0}, 
{0, 0, 0, 0, 0, 0, 0, 0}, 
{0, 1, 0, 1, 1, 1, 1, 0}, 
{0, 1, 0, 0, 0, 0, 0, 0}, 
{0, 1, 1, 1, 1, 1, 1, 0}, 
{0, 0, 0, 0, 0, 0, 0, 0}, 
{0, 1, 1, 1, 1, 1, 1, 0} }; 
int startX = 0, startY = 0; 
int endX = 7, endY = 7; 
int result = leeAlgorithm(grid, startX, startY, endX, endY); 
if (result != INT_MAX) { 
printf("Shortest path length is %d\n", result); 
} else { 
printf("No path found\n");} 
return 0;} 
 
<b>Output:</b>

Shortest path length is 14

<hr/>
 
 <h2>10. Hadlock Algorithm </h2>

#include < stdio.h> 
#include < stdlib.h> 
#include < stdbool.h> 
#include < limits.h> 
#define ROW 8 
#define COL 8 
int dRow[] = {-1, 1, 0, 0}; 
int dCol[] = {0, 0, -1, 1}; 
typedef struct { 
int row, col, cost; 
} Node; 
typedef struct { 
Node* nodes; 
int front, rear, size; 
int capacity; 
} Queue; 
Queue* createQueue(int capacity) { 
Queue* queue = (Queue*)malloc(sizeof(Queue)); 
queue->capacity = capacity; 
queue->front = queue->size = 0; 
queue->rear = capacity - 1; 
queue->nodes = (Node*)malloc(queue->capacity * sizeof(Node)); 
return queue;} 
bool isEmpty(Queue* queue) { 
return (queue->size == 0);} 
void enqueue(Queue* queue, Node node) { 
queue->rear = (queue->rear + 1) % queue->capacity; 
queue->nodes[queue->rear] = node; 
queue->size = queue->size + 1;} 
Node dequeue(Queue* queue) { 
Node node = queue->nodes[queue->front]; 
queue->front = (queue->front + 1) % queue->capacity; 
queue->size = queue->size - 1; 
return node;} 
bool isValid(int grid[ROW][COL], bool visited[ROW][COL], int row, int col) { 
return (row >= 0) && (row < ROW) && (col >= 0) && (col < COL) && 
(grid[row][col] == 0) && (!visited[row][col]);} 
int hadlock(int grid[ROW][COL], int startX, int startY, int endX, int endY) { 
bool visited[ROW][COL]; 
int i,j; 
for (i = 0; i < ROW; i++) { 
for (j = 0; j < COL; j++) { 
visited[i][j] = false; 
} } 
Queue* queue = createQueue(ROW * COL); 
Node start = {startX, startY, 0}; 
enqueue(queue, start); 
visited[startX][startY] = true; 
while (!isEmpty(queue)) { 
Node current = dequeue(queue); 
if (current.row == endX && current.col == endY) { 
free(queue->nodes); 
free(queue); 
return current.cost; } 
for (i = 0; i < 4; i++) { 
int newRow = current.row + dRow[i]; 
int newCol = current.col + dCol[i]; 
if (isValid(grid, visited, newRow, newCol)) { 
visited[newRow][newCol] = true; 
Node adjNode = {newRow, newCol, current.cost + 1}; 
enqueue(queue, adjNode); } } } 
free(queue->nodes); 
free(queue); 
return INT_MAX; 
} 
int main() { 
int grid[ROW][COL] = { 
{0, 1, 0, 0, 0, 0, 0, 0}, 
{0, 1, 0, 1, 1, 1, 1, 0}, 
{0, 0, 0, 0, 0, 0, 0, 0}, 
{1, 1, 0, 1, 1, 1, 1, 0}, 
{0, 1, 0, 0, 0, 0, 0, 0}, 
{0, 1, 1, 1, 1, 1, 1, 0}, 
{0, 0, 0, 0, 0, 0, 0, 0}, 
{1, 1, 1, 1, 1, 1, 1, 0} 
}; 
int startX = 0, startY = 0; 
int endX = 7, endY = 9; 
int result = hadlock(grid, startX, startY, endX, endY); 
if (result != INT_MAX) { 
printf("Shortest path length is %d\n", result); 
} else { 
printf("No path found\n"); 
}return 0;} 
 
<b>Output:</b>
 
No path found

<hr/>

 
 <h2>11. Constraint Based Methods </h2>

#include < stdio.h> 
#include < stdlib.h> 
#include < stdbool.h> 
#define N 8 
void printSolution(int board[N][N]) { 
int i,j; 
for (i = 0; i < N; i++) { 
for ( j = 0; j < N; j++) { 
printf(" %d ", board[i][j]); } 
printf("\n");}} 
bool isSafe(int board[N][N], int row, int col) { int i, j; 
for (i = 0; i < col; i++) 
if (board[row][i]) 
return false; 
for (i = row, j = col; i >= 0 && j >= 0; i--, j--) 
if (board[i][j]) 
return false; 
for (i = row, j = col; j >= 0 && i < N; i++, j--) 
if (board[i][j]) 
return false; 
return true;} 
bool solveNQUtil(int board[N][N], int col) { 
int i; 
if (col >= N) 
return true; 
for (i = 0; i < N; i++) { 
if (isSafe(board, i, col)) { 
board[i][col] = 1; 
if (solveNQUtil(board, col + 1)) 
return true; 
board[i][col] = 0;  } }      
return false;} 
bool solveNQ() { 
int board[N][N] = {0}; 
if (solveNQUtil(board, 0) == false) { 
printf("Solution does not exist"); 
return false;  } 
printSolution(board); 
return true; } 
int main() { 
solveNQ(); 
return 0; } 

<b>Output:</b>

 1  0  0  0  0  0  0  0 
 0  0  0  0  0  0  1  0 
 0  0  0  0  1  0  0  0 
 0  0  0  0  0  0  0  1 
 0  1  0  0  0  0  0  0 
 0  0  0  1  0  0  0  0 
 0  0  0  0  0  1  0  0 
 0  0  1  0  0  0  0  0 

 <hr/>

 
  <h2>12. Integer Programming -Based Methods</h2>

#include < stdio.h> 
#include < stdlib.h> 
typedef struct { 
int value; 
int weight; 
} Item; 
int max(int a, int b) { 
return (a > b) ? a : b; 
} 
int knapsack(int W, Item items[], int n, int **dp) { 
if (n == 0 || W == 0) { 
return 0; } 
if (dp[n][W] != -1) { 
return dp[n][W];} 
if (items[n-1].weight > W) { 
dp[n][W] = knapsack(W, items, n-1, dp); 
} else { 
dp[n][W] = max(items[n-1].value + knapsack(W - items[n-1].weight, items, n-1, dp), 
knapsack(W, items, n-1, dp)); } 
return dp[n][W]; } 
int main() { 
Item items[] = {{15, 1}, {10, 5}, {9, 3}, {5, 4}}; 
int n = sizeof(items) / sizeof(items[0]); 
int weight_limit = 8; 
int **dp = (int **)malloc((n + 1) * sizeof(int *)); 
int i,j; 
for (i = 0; i <= n; i++) { 
dp[i] = (int *)malloc((weight_limit + 1) * sizeof(int)); 
for (j = 0; j <= weight_limit; j++) { 
dp[i][j] = -1; } } 
int max_value = knapsack(weight_limit, items, n, dp); 
printf("Maximum value in Knapsack = %d\n", max_value); 
for (i = 0; i <= n; i++) { 
free(dp[i]); } 
free(dp); 
return 0; } 
 
<b>Output:</b>

Maximum value in Knapsack = 29

<hr/>

    </pre>
</body>
</html>